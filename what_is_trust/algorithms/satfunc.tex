\Suppressnumber
\begin{lstlisting}[label=satfunc, style=numbers]
(*@$\mathcal{F}_{SAT}$ \Reactivatenumber@*)
Declarations:
  boolean allSet
  set pendingDesires
  map isSet((*@$\mathcal{P}$@*) => boolean)
  map price((*@$\mathcal{P}$@*) => map ((*@$\mathcal{D}$@*) => number)) (*@\newline@*) # Maybe just the best price is enough?
  map tokens((*@$\mathcal{P}$@*) => number)
  map fulfillment((*@$\mathcal{P}$@*) => map ((*@$\mathcal{D}$@*) => SAT))
  map utility((*@$\mathcal{P}$@*) => function((*@$2^{\mathcal{D}}$@*), (*@$2^{\mathcal{D}}$@*)): number) (*@\newline@*) # This map has hardcoded values

Initialization:
  allSet = False
  pendingDesires = (*@$\emptyset$@*)
  (*@$\forall$@*) (*@$Alice \in \mathcal{P}$@*)
    isSet((*@$Alice$@*)) = False
    price((*@$Alice$@*)) = null
    tokens((*@$Alice$@*)) = (*@$\mathcal{F}_{Ledger}$@*).getTokens((*@$Alice$@*))
    (*@$\forall$@*) desire (*@$\in \mathcal{D}$@*)
      fulfillment((*@$Alice$@*))(desire) = null

Upon receiving message (*@\newline@*) init(map prices((*@$\mathcal{D}$@*) => number)) from (*@$\mathcal{P}$@*) (*@$Alice$@*):
  If isSet((*@$Alice$@*)) == False
    isSet((*@$Alice$@*)) = True
    price((*@$Alice$@*)) = prices
    If (*@$\forall$@*) (*@$Bob \in \mathcal{P},$@*) isSet((*@$Bob$@*)) == True
      allSet = True

Upon receiving message cost((*@$\mathcal{P}$@*) (*@$Bob$@*), (*@$\mathcal{D}$@*) desire) from (*@$\mathcal{P}$@*) (*@$Alice$@*):
  If allSet == True
    send message price((*@$Bob$@*))(desire) to (*@$Alice$@*)

Upon receiving message satisfy((*@$\mathcal{D}$@*) desire) from (*@$\mathcal{P}$@*) (*@$Alice$@*):
  If allSet == True
    number minPrice = (*@$\min\limits_{Bob \in \mathcal{P}}\left\{\right.$@*)price((*@$Bob$@*))(desire)(*@$\left.\right\}$@*)
    If tokens((*@$Alice$@*)) (*@$\geq$@*) minPrice
      tokens((*@$Alice$@*)) = tokens((*@$Alice$@*)) - minPrice
      fulfillment((*@$Alice$@*))(desire) = (*@$s$@*)((*@$Alice$@*), desire)
    Else
      support = shouldBeSatisfied((*@$Alice$@*), desire, minPrice)
      If support (*@$\neq$@*) []
        (*@$\forall$@*) i (*@$\in$@*) [1, ...,(*@$|\mathcal{P}|$@*)]
          tokens((*@$P_{\mbox{i}}$@*)) = tokens((*@$P_{\mbox{i}}$@*)) - support[i]
        fulfillment((*@$Alice$@*))(desire) = (*@$s$@*)((*@$Alice$@*), desire)
      Else # desire remains unsatisfied
        pendingDesires = pendingDesires (*@$\cup$@*) ((*@$Alice$@*), desire)
    Attempt to satisfy desires from pendingDesires (*@\newline@*) # How? Also, could be (*@$\mathcal{F}_{SAT}$@*) idle action

Upon receiving message (*@\newline@*) getFulfillment((*@$\mathcal{D}$@*) desire) from (*@$\mathcal{P}$@*) (*@$Alice$@*):
  If allSet == True
    send message fulfillment((*@$Alice$@*))(desire) to (*@$Alice$@*)

shouldBeSatisfied((*@$\mathcal{P}$@*) (*@$Alice$@*), (*@$\mathcal{D}$@*) desire, number minPrice) returns number[]:
  support = chooseSupport(minPrice)
  utilityWithout = (u((*@$P_1$@*))(satDesires((*@$P_1$@*)), unsatDesires((*@$P_1$@*))), ..., u((*@$P_n$@*))(satDesires((*@$P_n$@*)), unsatDesires((*@$P_n$@*))))
  utilityWith = (u((*@$P_1$@*))(satDesires((*@$P_1$@*)), unsatDesires((*@$P_1$@*))) - support[1], ..., u((*@$P_n$@*))(satDesires((*@$P_n$@*)), unsatDesires((*@$P_n$@*))) - support[n]) (*@\newline@*) # Should tokens be equated with utility points?
  If utilityWithout < utilityWith (*@\newline@*) # Define this comparison
    return support
  Else
    return []

chooseSupport(number price) returns number[(*@$|\mathcal{P}|$@*)]
# Chooses to charge the richest players (not the best idea)
# See also Absolute Equality Trust Transfer, github.com/OrfeasLitos/TrustIsRisk/blob/master/thesis.pdf, p. 29  

satDesires((*@$\mathcal{P}$@*) (*@$Alice$@*)) returns set (*@$\subset$@*) (*@$\mathcal{D}$@*):
  ret = (*@$\emptyset$@*)
  (*@$\forall$@*) desire (*@$\in$@*) (*@$\mathcal{D}$@*)
    if fulfillment((*@$Alice$@*))(desire) (*@$\neq$@*) null
    ret = ret (*@$\cup$@*) desire
  return ret

unsatDesires((*@$\mathcal{P}$@*) (*@$Alice$@*)) returns set (*@$\subset$@*) (*@$\mathcal{D}$@*):
  ret = (*@$\emptyset$@*)
  (*@$\forall$@*) desire (*@$\in$@*) (*@$\mathcal{D}$@*)
    if fulfillment((*@$Alice$@*))(desire) == null
    ret = ret (*@$\cup$@*) desire
  return ret

# May be redundant
transfer((*@$\mathcal{P}$@*) (*@$Alice$@*), (*@$\mathcal{P}$@*) (*@$Bob$@*), number tokens):
  If allSet == True
    If tokens((*@$Alice$@*)) (*@$\geq$@*) tokens
      tokens((*@$Alice$@*)) = tokens((*@$Alice$@*)) - tokens
      tokens((*@$Bob$@*)) = tokens((*@$Bob$@*)) + tokens
\end{lstlisting}
